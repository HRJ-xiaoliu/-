const fs = require('fs')
const path = require('path')
const stripJsonComments = require('strip-json-comments')
const { RuleHelper } = require('textlint-rule-helper')

const DEFAULT_OPTIONS = {
  terms: [],
  skip: ['BlockQuote'],
  defaultTerms: true,
  exclude: [],
}
const sentenceStartRegExp = /\w+[.?!]\)? $/

/**
 * @param {string} str
 * @return {string}
 */
function upperFirst(str) {
  return str.replace(/^\w/, char => char.toUpperCase())
}

/**
 * Check if pattern include Chinese
 * @description “中国 China” will return true
 * @param pattern
 * @return {boolean}
 */
function isChinese(pattern) {
  return /\p{sc=Han}/gu.test(pattern)
}

/**
 * main entrance
 * @param {object} context
 * @param {object} opts
 * @param {array|string} opts.terms array: list of terms；string：path to custom terms.jsonc
 * @param {boolean} opts.defaultTerms use default terms
 * @param {string[]} opts.skip
 * @param {string[]} opts.exclude
 * @return {{}|Promise<unknown>|boolean}
 */
function reporter(context, opts = {}) {
  const { Syntax, RuleError, report, fixer, getSource } = context
  const helper = new RuleHelper(context)
  const options = { ...DEFAULT_OPTIONS, ...opts }
  const SyntaxToSkip = options.skip.map(rule => Syntax[rule])
  const terms = getTerms(options.defaultTerms, options.terms, options.exclude)
  const rules = getRules(terms)

  return {
    [Syntax.Str](node) {
      if (helper.isChildNode(node, SyntaxToSkip)) {
        return false
      }

      return new Promise(resolve => {
        const text = getSource(node)

        rules.forEach(([pattern, replacements]) => {
          const regExp = pattern

          let match
          // eslint-disable-next-line no-cond-assign
          while ((match = regExp.exec(text))) {
            const index = match.index
            const matched = match[0]

            let replacement = getReplacement(pattern, replacements, matched)

            // Capitalize word in the beginning of a sentence if the original word was capitalized
            const textBeforeMatch = text.substring(0, index)
            const isSentenceStart =
              index === 0 || sentenceStartRegExp.test(textBeforeMatch)
            if (isSentenceStart && upperFirst(matched) === matched) {
              replacement = upperFirst(replacement)
            }

            // Skip correct spelling
            if (matched === replacement) {
              continue
            }

            const range = [index, index + matched.length]
            const fix = fixer.replaceTextRange(range, replacement)
            const message = `Incorrect usage of the term: “${matched.trim()}”, use “${replacement.trim()}” instead`
            report(node, new RuleError(message, { index, fix }))
          }
        })

        resolve()
      })
    },
  }
}

/**
 * @param {boolean} defaultTerms
 * @param {string | Array} terms
 * @param {Array} [exclude]
 */
function getTerms(defaultTerms, terms, exclude) {
  const defaults = defaultTerms
    ? loadJson(path.resolve(__dirname, 'terms.jsonc'))
    : []
  const extras = typeof terms === 'string' ? loadJson(terms) : terms
  // Order matters, the latter term to match is used. We prioritize user 'extras' before defaults
  const listTerms = [...defaults, ...(Array.isArray(extras) ? extras : [])]

  // Filter on all terms
  if (Array.isArray(exclude)) {
    return listTerms.filter(term => {
      if (Array.isArray(term)) {
        return !exclude.includes(term[0])
      }
      return !exclude.includes(term)
    })
  }
  return listTerms
}

/**
 * Get reg rules
 * @param {array} terms
 * @return {[RegExp, string][]}
 */
function getRules(terms) {
  const EnglishWordsMap = {}
  const ChineseWordsMap = {}
  const patternReplacementMap = {}
  // useMap to filter duplicated terms
  terms.forEach(rule => {
    // Match all words (plain strings) with a single regexp
    if (typeof rule === 'string') {
      if (isChinese(rule)) {
        ChineseWordsMap[rule] = rule
      } else {
        // if rules are only different in alphabet case, the latter one will override the former one
        EnglishWordsMap[rule.toUpperCase()] = rule
      }
    } else {
      const [pattern, replacements] = rule
      // latter pattern will override former pattern
      patternReplacementMap[pattern] = [
        getAdvancedRegExp(pattern),
        replacements,
      ]
    }
  })

  const EnglishWords = Object.values(EnglishWordsMap)
  const ChineseWords = Object.values(ChineseWordsMap)
  // Join all words into one big regExpression
  const exactWordRules = [
    EnglishWords.length > 0 ? [getMultipleWordRegExp(EnglishWords), EnglishWords] : null,
    // Since Chinese has no space between words, this rule use quick match regExpression.
    ChineseWords.length > 0 ? [getMultipleWordRegExp(ChineseWords, true), ChineseWords] : null,
  ].filter(Boolean)

  // Create a separate regexp of each array rule ([regPattern, replacement])
  const advancedRules = Object.values(patternReplacementMap)

  return [...exactWordRules, ...advancedRules]
}

/**
 * @param {string} filepath
 */
function loadJson(filepath) {
  const json = readTermsFile(path.resolve(filepath))
  return JSON.parse(stripJsonComments(json))
}

/**
 * @param {string} filepath
 */
function readTermsFile(filepath) {
  try {
    return fs.readFileSync(filepath, 'utf8')
  } catch (err) {
    if (err.code === 'ENOENT') {
      throw new Error(`Terms file not found: ${filepath}`)
    } else {
      throw err
    }
  }
}

/**
 *
 * Match exact word in the middle of the text
 * @param {string} pattern
 * @return {RegExp}
 */
function getExactMatchRegExp(pattern) {
  const punctuation = '[\\.,;\'")]'
  return new RegExp(
    // 1. Beginning of the string, or any character that isn't "-" or alphanumeric
    // 2. Exact match of the pattern
    // 3. Space, punctuation + space, punctuation + punctuation, or punctuation at the end of the string, end of the string
    `(?<=^|[^-\\w])\\b${pattern}\\b(?= |${punctuation} |${punctuation}${punctuation}|${punctuation}$|$)`,
    'ig',
  )
}

/**
 * Join all string words into one giant regExpression
 * Match any of given words exactly in the middle of the text
 * @param {string[]} words
 * @param {boolean} [isQuickMatch]
 * @return {RegExp}
 */
function getMultipleWordRegExp(words, isQuickMatch) {
  // Ignore punctuation and generate regExpression
  if (isQuickMatch) {
    return new RegExp(`(?:${words.join('|')})`, 'ig')
  }
  return getExactMatchRegExp(`(?:${words.join('|')})`)
}

/**
 *
 * Match pattern on word boundaries in the middle of the text unless the pattern
 * has look behinds
 * @param {string} pattern
 * @return {RegExp}
 */
function getAdvancedRegExp(pattern) {
  if (
    // Look behind: (?<=...) and (?<!...)
    pattern.startsWith('(?<') ||
    // Positive look ahead: (?=...)
    pattern.includes('(?=') ||
    // Negative look ahead: (?!...)
    pattern.includes('(?!') ||
    // Chinese
    isChinese(pattern)
  ) {
    return new RegExp(pattern, 'ig')
  }
  return getExactMatchRegExp(pattern)
}

/**
 * Replace original string with replacements
 * @param {string|RegExp} pattern
 * @param {string[]|string} replacements
 * @param {string} matched
 * @return {string}
 */
function getReplacement(pattern, replacements, matched) {
  if (Array.isArray(replacements)) {
    return findWord(replacements, matched)
  }

  // Sometimes replacements is a template with $1 or other reg keyword, so we need to use replace method
  return `xyz ${matched} xyz`
    .replace(new RegExp(pattern, 'i'), replacements)
    .slice(4, -4)
}

/**
 *
 * @param {string[]} items
 * @param {string} match
 * @return {string}
 */
function findWord(items, match) {
  const lowerCaseMatch = match.toLowerCase()
  return items.find(word => word.toLowerCase() === lowerCaseMatch)
}

module.exports = {
  linter: reporter,
  fixer: reporter,
  test: {
    getTerms,
    findWord,
    getMultipleWordRegExp,
    getExactMatchRegExp,
    getAdvancedRegExp,
    getReplacement,
  },
}
