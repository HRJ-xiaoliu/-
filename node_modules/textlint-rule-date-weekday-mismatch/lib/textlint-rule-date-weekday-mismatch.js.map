{"version":3,"sources":["../src/textlint-rule-date-weekday-mismatch.js"],"names":["chrono","require","moment","supportedLang","textIncludesNumber","chronoDate","test","text","yearMonthDayShouldKnownValues","start","kV","knownValues","year","undefined","month","day","detectLang","tags","preferLang","targetLangs","filter","langRegExp","some","tag","length","selectedLang","reporter","context","config","lang","Syntax","RuleError","report","fixer","getSource","Intl","Error","Str","node","chronoDates","parse","filteredChronoDates","forEach","Object","keys","$moment","error","isValid","startOfPairSymbol","index","slicedText","slice","match","actualDateText","actualTextAll","pairStartSymbol","pairEndSymbol","maybeWeekdayText","trim","paddingIndex","weekdayPatterns","localeData","weekdaysMin","weekdaysShort","weekdays","format","symbols","indexOf","expectedWeekday","fix","replaceTextRange","module","exports","linter"],"mappings":"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","sourcesContent":["// MIT © 2016 azu\n\"use strict\";\nconst chrono = require(\"chrono-node\");\nconst moment = require('moment');\n/**\n * from chrono tags\n * TODO: get more primitive way\n * @type {[RegExp]}\n */\nconst supportedLang = [\n    [/^EN/i, \"en\"],\n    [/^JP/i, \"ja\"],\n    [/^ES/i, \"es\"],\n    [/^FR/i, \"fr\"],\n    [/^ZH/i, \"zh\"]\n];\n/**\n * text should be includes number\n * @param {Object} chronoDate\n * @returns {boolean}\n */\nconst textIncludesNumber = (chronoDate) => {\n    return /[0-9０-９]/.test(chronoDate.text);\n};\nconst yearMonthDayShouldKnownValues = (chronoDate) => {\n    if (!chronoDate.start) {\n        return false;\n    }\n    // year-month-day should known value\n    // if have not anyone, not report as error\n    const kV = chronoDate.start.knownValues;\n    return kV.year !== undefined && kV.month !== undefined && kV.day !== undefined;\n};\n/**\n * detect lang and return language string\n * @param {string[]} tags\n * @param {string} [preferLang]\n * @returns {string|null}\n */\nconst detectLang = (tags, preferLang) => {\n    if (preferLang) {\n        return preferLang;\n    }\n    const targetLangs = supportedLang.filter(([langRegExp]) => {\n        return tags.some(tag => langRegExp.test(tag));\n    });\n    if (targetLangs.length === 0) {\n        return null;\n    }\n    const selectedLang = targetLangs[0];\n    return selectedLang[1];\n};\n/**\n *\n * @param context\n * @param {Object} [config]\n */\nfunction reporter(context, config = {}) {\n    const preferLang = config.lang;\n    const {Syntax, RuleError, report, fixer, getSource} = context;\n    if (typeof Intl === \"undefined\") {\n        throw new Error(\"Not support your Node.js/browser. should be use latest version.\");\n    }\n\n    return {\n        [Syntax.Str](node){\n            const text = getSource(node);\n            const chronoDates = chrono.parse(text);\n            // ignore \"今日\" text\n            // ignore not valid data\n            const filteredChronoDates = chronoDates.filter(textIncludesNumber).filter(yearMonthDayShouldKnownValues);\n            filteredChronoDates.forEach(chronoDate => {\n                const lang = detectLang(Object.keys(chronoDate.tags), preferLang);\n                if (!lang) {\n                    // not found lang\n                    return;\n                }\n                // get weekday from actual date string\n                const kV = chronoDate.start.knownValues;\n                let $moment;\n                try {\n                    $moment = moment(`${kV.year}-${kV.month}-${kV.day}`, \"YYYY-MM-DD\", lang);\n                } catch (error) {\n                    report(node, new RuleError(`Maybe textlint-rule-date-weekday-mismatch options was wrong language. lang: ${lang}`));\n                    // parse error is ignore\n                    return;\n                }\n                if (!$moment.isValid()) {\n                    return;\n                }\n                // get (weekday)\n                const startOfPairSymbol = chronoDate.text.length + chronoDate.index;\n                const slicedText = text.slice(startOfPairSymbol);\n                // (match) or （match）\n                const match = slicedText.match(/^(\\s*?[(（])([^(（)]+)([)）])/);\n                if (!match) {\n                    return;\n                }\n                const actualDateText = match[0];\n                const actualTextAll = `${chronoDate.text}${actualDateText}`;\n                const pairStartSymbol = match[1];// ( and padding-left\n                const pairEndSymbol = match[3]; // )\n                const maybeWeekdayText = match[2].trim(); // weekday\n                // 2016年12月30日                  (金曜日)\n                //       ^               ^        ^\n                // chronoDate.index  match.index  pairStartSymbol.length\n                const paddingIndex = startOfPairSymbol + match.index + pairStartSymbol.length;\n                // format http://momentjs.com/docs/#/parsing/string-format/\n                const weekdayPatterns = [\n                    // date-format , symbols\n                    [\"dd\", moment.localeData(lang).weekdaysMin()],\n                    [\"ddd\", moment.localeData(lang).weekdaysShort()],\n                    [\"dddd\", moment.localeData(lang).weekdays()]\n                ];\n                weekdayPatterns.forEach(([format, symbols]) => {\n                    if (symbols.indexOf(maybeWeekdayText) === -1) {\n                        return;\n                    }\n                    // e.g.) \"Friday\"\n                    const expectedWeekday = $moment.format(format);\n                    if (maybeWeekdayText !== expectedWeekday) {\n                        const fix = fixer.replaceTextRange(\n                            [paddingIndex, paddingIndex + maybeWeekdayText.length],\n                            expectedWeekday\n                        );\n                        report(node, new RuleError(`${actualTextAll} mismatch weekday.\\n${actualTextAll} => ${chronoDate.text}${pairStartSymbol}${expectedWeekday}${pairEndSymbol}`, {\n                            index: paddingIndex,\n                            fix\n                        }));\n                    }\n                });\n            });\n        }\n    };\n}\nmodule.exports = {\n    linter: reporter,\n    fixer: reporter\n};\n"],"file":"textlint-rule-date-weekday-mismatch.js"}