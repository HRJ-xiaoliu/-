// MIT © 2016 azu
"use strict";

var chrono = require("chrono-node");

var moment = require('moment');
/**
 * from chrono tags
 * TODO: get more primitive way
 * @type {[RegExp]}
 */


var supportedLang = [[/^EN/i, "en"], [/^JP/i, "ja"], [/^ES/i, "es"], [/^FR/i, "fr"], [/^ZH/i, "zh"]];
/**
 * text should be includes number
 * @param {Object} chronoDate
 * @returns {boolean}
 */

var textIncludesNumber = chronoDate => {
  return /[0-9０-９]/.test(chronoDate.text);
};

var yearMonthDayShouldKnownValues = chronoDate => {
  if (!chronoDate.start) {
    return false;
  } // year-month-day should known value
  // if have not anyone, not report as error


  var kV = chronoDate.start.knownValues;
  return kV.year !== undefined && kV.month !== undefined && kV.day !== undefined;
};
/**
 * detect lang and return language string
 * @param {string[]} tags
 * @param {string} [preferLang]
 * @returns {string|null}
 */


var detectLang = (tags, preferLang) => {
  if (preferLang) {
    return preferLang;
  }

  var targetLangs = supportedLang.filter(_ref => {
    var [langRegExp] = _ref;
    return tags.some(tag => langRegExp.test(tag));
  });

  if (targetLangs.length === 0) {
    return null;
  }

  var selectedLang = targetLangs[0];
  return selectedLang[1];
};
/**
 *
 * @param context
 * @param {Object} [config]
 */


function reporter(context) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var preferLang = config.lang;
  var {
    Syntax,
    RuleError,
    report,
    fixer,
    getSource
  } = context;

  if (typeof Intl === "undefined") {
    throw new Error("Not support your Node.js/browser. should be use latest version.");
  }

  return {
    [Syntax.Str](node) {
      var text = getSource(node);
      var chronoDates = chrono.parse(text); // ignore "今日" text
      // ignore not valid data

      var filteredChronoDates = chronoDates.filter(textIncludesNumber).filter(yearMonthDayShouldKnownValues);
      filteredChronoDates.forEach(chronoDate => {
        var lang = detectLang(Object.keys(chronoDate.tags), preferLang);

        if (!lang) {
          // not found lang
          return;
        } // get weekday from actual date string


        var kV = chronoDate.start.knownValues;
        var $moment;

        try {
          $moment = moment("".concat(kV.year, "-").concat(kV.month, "-").concat(kV.day), "YYYY-MM-DD", lang);
        } catch (error) {
          report(node, new RuleError("Maybe textlint-rule-date-weekday-mismatch options was wrong language. lang: ".concat(lang))); // parse error is ignore

          return;
        }

        if (!$moment.isValid()) {
          return;
        } // get (weekday)


        var startOfPairSymbol = chronoDate.text.length + chronoDate.index;
        var slicedText = text.slice(startOfPairSymbol); // (match) or （match）

        var match = slicedText.match(/^(\s*?[(（])([^(（)]+)([)）])/);

        if (!match) {
          return;
        }

        var actualDateText = match[0];
        var actualTextAll = "".concat(chronoDate.text).concat(actualDateText);
        var pairStartSymbol = match[1]; // ( and padding-left

        var pairEndSymbol = match[3]; // )

        var maybeWeekdayText = match[2].trim(); // weekday
        // 2016年12月30日                  (金曜日)
        //       ^               ^        ^
        // chronoDate.index  match.index  pairStartSymbol.length

        var paddingIndex = startOfPairSymbol + match.index + pairStartSymbol.length; // format http://momentjs.com/docs/#/parsing/string-format/

        var weekdayPatterns = [// date-format , symbols
        ["dd", moment.localeData(lang).weekdaysMin()], ["ddd", moment.localeData(lang).weekdaysShort()], ["dddd", moment.localeData(lang).weekdays()]];
        weekdayPatterns.forEach(_ref2 => {
          var [format, symbols] = _ref2;

          if (symbols.indexOf(maybeWeekdayText) === -1) {
            return;
          } // e.g.) "Friday"


          var expectedWeekday = $moment.format(format);

          if (maybeWeekdayText !== expectedWeekday) {
            var fix = fixer.replaceTextRange([paddingIndex, paddingIndex + maybeWeekdayText.length], expectedWeekday);
            report(node, new RuleError("".concat(actualTextAll, " mismatch weekday.\n").concat(actualTextAll, " => ").concat(chronoDate.text).concat(pairStartSymbol).concat(expectedWeekday).concat(pairEndSymbol), {
              index: paddingIndex,
              fix
            }));
          }
        });
      });
    }

  };
}

module.exports = {
  linter: reporter,
  fixer: reporter
};
//# sourceMappingURL=textlint-rule-date-weekday-mismatch.js.map